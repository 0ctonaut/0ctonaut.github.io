<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode-224</title>
    <link href="/posts/b5d1488d/"/>
    <url>/posts/b5d1488d/</url>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/basic-calculator/description">有这么一道题</a>，给你一个由整数、小括号、加减号、负号、空格组成的表达式字符串，求值。</p><p>第一直觉是分数字栈和符号栈将字符逐个入栈，碰到右半小括号再暂时出栈。出栈操作为取一个符号，取俩操作数，计算后将计算结果再塞入数字栈。最后的结果为栈顶——也是唯一的元素。</p><p>这样能解决除了负号外的问题，因为类似负号的单操作符不能直接取俩操作数。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>那么对于负号，我的想法是扫描字符串入栈的时候，用一个标志<code>isLastNum</code>检测上一个有效字符是否是数字，如果是，则说面当前负号是双操作符；否则是单操作符，则再向数字压入一个<code>0</code>，计算时统一将负号当作双操作数处理。</p><p>因为碰到<code>)</code>就取两个操作数来计算，是从右往左计算，所以出栈计算的时候还需要判断接下来一个操作符是不是负号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        std::stack&lt;<span class="hljs-type">int</span>&gt; numStk;<br>        std::stack&lt;<span class="hljs-type">char</span>&gt; opStk;<br><br>        <span class="hljs-keyword">auto</span> func = [&amp;] &#123;<br>            <span class="hljs-keyword">while</span> (!opStk.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-type">char</span> opTop = opStk.<span class="hljs-built_in">top</span>();<br>                opStk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (opTop == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> num1 = numStk.<span class="hljs-built_in">top</span>();<br>                numStk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = numStk.<span class="hljs-built_in">top</span>();<br>                numStk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (opTop == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                &#123;<br>                    numStk.<span class="hljs-built_in">push</span>( (!opStk.<span class="hljs-built_in">empty</span>() &amp;&amp; opStk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>) ? (num2 + num1) : (num2 - num1));<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opTop == <span class="hljs-string">&#x27;+&#x27;</span>)<br>                &#123;<br>                    numStk.<span class="hljs-built_in">push</span>( (!opStk.<span class="hljs-built_in">empty</span>() &amp;&amp; opStk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>) ? (num2 - num1) : (num2 + num1));<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> isHasNum = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> isLastNum = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-type">char</span> cha = s[i];<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">isdigit</span>(cha))<br>            &#123;<br>                num *= <span class="hljs-number">10</span>;<br>                num += cha - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                isHasNum = <span class="hljs-literal">true</span>;<br>                isLastNum = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(isHasNum)<br>                &#123;<br>                    numStk.<span class="hljs-built_in">push</span>(num);<br>                    num = <span class="hljs-number">0</span>;<br>                    isHasNum = <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cha == <span class="hljs-string">&#x27; &#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cha == <span class="hljs-string">&#x27;)&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">func</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    opStk.<span class="hljs-built_in">push</span>(cha);<br><br>                    <span class="hljs-keyword">if</span>(!isLastNum &amp;&amp; cha == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                    &#123;<br>                        numStk.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>                    &#125;<br><br>                    isLastNum = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isHasNum)<br>        &#123;<br>            numStk.<span class="hljs-built_in">push</span>(num);<br>            num = <span class="hljs-number">0</span>;<br>            isHasNum = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">func</span>();<br><br>        <span class="hljs-keyword">return</span> numStk.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-76</title>
    <link href="/posts/74f7fcf3/"/>
    <url>/posts/74f7fcf3/</url>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/minimum-window-substring/description">有这么一道题</a>，给你一个字符串主串<code>s</code>和模式串<code>t</code>，问<code>s</code>有没有子串包含<code>t</code>中所有字符，顺序无关，每个单词只能参与一次，所有单词都要用上。和leetcode-30的区别是不用正好完全由<code>t</code>中的所有字符构成，只需要包含。求满足该条件的最短子串。</p><p>那我必然一上来先滑动窗口。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding-Window"></a>Sliding-Window</h2><p>因为写这题前刚写完leetcode-30，区别在于，这题允许容纳无关字符，而上一题需要完美包含所有单词，多一个少一个都不行，所以本题需要注意刷新最短字符串的条件。</p><p>注意存一个索引minL，不要每次刷新结果字符串，差点MLE了，计算机真的太坏了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minLength = <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> minL = <span class="hljs-number">0</span>;<br><br>        std::unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; strMap;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            strMap[t[i]]++;<br>        &#125;<br><br>        std::unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; collectedMap;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; s.<span class="hljs-built_in">size</span>(); ++r)<br>        &#123;<br>            <span class="hljs-type">char</span> newCha = s[r];<br>            <span class="hljs-keyword">if</span> (strMap[newCha] &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (collectedMap[newCha] &lt; strMap[newCha])<br>                    ++cnt;<br>                ++collectedMap[newCha];<br><br>                <span class="hljs-keyword">while</span> (cnt &gt;= t.<span class="hljs-built_in">size</span>())<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; minLength)<br>                    &#123;<br>                        minLength = r - l + <span class="hljs-number">1</span>;<br>                        minL = l;<br>                    &#125;<br>                    <span class="hljs-type">char</span> oldCha = s[l];<br>                    <span class="hljs-keyword">if</span> (strMap[oldCha] &gt; <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (collectedMap[oldCha] &lt;= strMap[oldCha])<br>                        &#123;<br>                            --cnt;<br>                        &#125;<br>                        --collectedMap[oldCha];<br>                    &#125;<br>                    ++l;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLength &gt; <span class="hljs-number">1e5</span> + <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(minL, minLength);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sliding-window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-30</title>
    <link href="/posts/f9f89cc2/"/>
    <url>/posts/f9f89cc2/</url>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/description">有这么一道题</a>，给你一个字符串<code>s</code>和单词列表<code>words</code>，问<code>s</code>有没有子串正好由<code>words</code>中所有单词排列而成，顺序无关，每个单词只能参与一次，所有单词都要用上。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="brutal-force"><a href="#brutal-force" class="headerlink" title="brutal force"></a>brutal force</h2><p>主要思想就是滑动大窗口，用单个单词长度的小窗口去选取单词，查询是否在<code>words</code>内。<br>但是在<code>s=&quot;aaaaaaaaaaaaaaaaaaaaa...&quot;, words = [&quot;a&quot;,&quot;a&quot;, ...]</code>的测试用例TLE了，大窗口一层、小窗口一层、查map一层，<code>O(n^3)</code>还是爆了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Time Limit Exceeded</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findSubstring</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        std::vector&lt;<span class="hljs-type">int</span>&gt; results;<br><br>        <span class="hljs-type">int</span> wordLength = words[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        std::map&lt;std::string, <span class="hljs-type">int</span>&gt; wordMap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            wordMap[words[i]]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + words.<span class="hljs-built_in">size</span>() * wordLength &lt;= s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>            std::map&lt;std::string, <span class="hljs-type">int</span>&gt; tempMap = wordMap;<br>            <span class="hljs-keyword">while</span>(j &lt; words.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                std::string word = s.<span class="hljs-built_in">substr</span>(i + j * wordLength, wordLength);<br>                <span class="hljs-keyword">if</span>(tempMap[word] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    tempMap[word]--;<br>                    ++j;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(j == words.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                results.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding-Window"></a>Sliding-Window</h2><p>上面暴力的代码有几处需要优化：</p><ul><li>循环方式有大问题，内层循环每次只循环<code>wordLength * words.size()</code>的长度，然后外层循环再往后递增1，这并不是<strong>滑动窗口</strong>。在单词长度为1的情况下，内外循环也有<code>10^(3+4)</code>数量级。我们可以一层遍历偏移，一层真正地滑动窗口，这样只有<code>10^(1+4)</code>数量级。</li><li>每次拷贝哈希表，改成新建一个哈希表，每次加入单词后和原始表比对</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findSubstring</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        std::vector&lt;<span class="hljs-type">int</span>&gt; results;<br><br>        <span class="hljs-type">int</span> wordLength = words[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; wordMap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            wordMap[words[i]]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>; offset &lt; wordLength; ++offset)<br>        &#123;<br>            std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; collectedWordMap;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = offset, left = offset; right + wordLength &lt;= s.<span class="hljs-built_in">size</span>(); right += wordLength)<br>            &#123;<br>                std::string newWord = s.<span class="hljs-built_in">substr</span>(right, wordLength);<br>                <span class="hljs-keyword">if</span>(wordMap[newWord] &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    ++collectedWordMap[newWord];<br>                    ++cnt;<br>                    <span class="hljs-keyword">while</span>(collectedWordMap[newWord] &gt; wordMap[newWord])<br>                    &#123;<br>                        std::string oldWord = s.<span class="hljs-built_in">substr</span>(left, wordLength);<br>                        --collectedWordMap[oldWord];<br>                        --cnt;<br>                        left += wordLength;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(cnt == words.<span class="hljs-built_in">size</span>())<br>                    &#123;<br>                        results.<span class="hljs-built_in">push_back</span>(left); <br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    collectedWordMap.<span class="hljs-built_in">clear</span>();<br>                    cnt = <span class="hljs-number">0</span>;<br>                    left = right + wordLength;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sliding-window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-68</title>
    <link href="/posts/8a54e0b5/"/>
    <url>/posts/8a54e0b5/</url>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/text-justification/description">有这么一道题</a>，给你一句字符串，按照规则塞入一个限宽的<code>string</code>数组中。</p><p>其中规则如下：</p><ol><li>“单词”定义为连续无空格的字符串，单词之间至少拥有一个空格；</li><li>数组的每个<code>string</code>等宽，宽度都是<code>maxWidth</code>，若宽度不足，需要补齐空格；</li><li>空格均匀分布，若不能均匀分布，在尽量均匀的情况下保证左边的空格数量更多；</li><li>对于只有一个单词的行，该行左对齐，即空格全部分布在单词右边；</li><li>数组的最后一行即使有多个单词，也需要在保证<code>1.</code>的前提下实现<code>4.</code></li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>没啥好说的，贪心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fullJustify</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> maxWidth)</span> </span>&#123;<br>        std::queue&lt;std::string&gt; line;<br>        <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        std::vector&lt;std::string&gt; results;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (width + cnt + words[i].<span class="hljs-built_in">size</span>() &gt; maxWidth)<br>            &#123;<br>                <span class="hljs-type">int</span> space = cnt &gt; <span class="hljs-number">1</span> ? ((maxWidth - width) / (cnt - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> remain = cnt &gt; <span class="hljs-number">1</span> ? ((maxWidth - width) % (cnt - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>                std::string result;<br>                <span class="hljs-keyword">while</span> (!line.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    std::string front = line.<span class="hljs-built_in">front</span>();<br>                    line.<span class="hljs-built_in">pop</span>();<br>                    result += front;<br>                    <span class="hljs-keyword">if</span> (!line.<span class="hljs-built_in">empty</span>())<br>                    &#123;<br>                        result += std::<span class="hljs-built_in">string</span>(space + (remain-- &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), <span class="hljs-string">&#x27; &#x27;</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)<br>                    &#123;<br>                        result += std::<span class="hljs-built_in">string</span>(maxWidth - width, <span class="hljs-string">&#x27; &#x27;</span>);<br>                    &#125;<br>                &#125;<br>                results.<span class="hljs-built_in">push_back</span>(result);<br>                cnt = <span class="hljs-number">0</span>;<br>                width = <span class="hljs-number">0</span>;<br>            &#125;<br>            line.<span class="hljs-built_in">push</span>(words[i]);<br>            width += words[i].<span class="hljs-built_in">size</span>();<br>            ++cnt;<br>        &#125;<br><br>        std::string result;<br>        <span class="hljs-keyword">while</span> (!line.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            std::string front = line.<span class="hljs-built_in">front</span>();<br>            line.<span class="hljs-built_in">pop</span>();<br>            result += front;<br>            <span class="hljs-keyword">if</span> (!line.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                result += <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result += std::<span class="hljs-built_in">string</span>(maxWidth - width - (cnt - <span class="hljs-number">1</span>), <span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>        &#125;<br>        results.<span class="hljs-built_in">push_back</span>(result);<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以用索引代替<code>std::queue</code>来优化一点空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fullJustify</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> maxWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> processingIndex = <span class="hljs-number">0</span>;<br>        std::string result;<br>        std::vector&lt;std::string&gt; results;<br>        <span class="hljs-type">int</span> n = words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (width + cnt + words[i].<span class="hljs-built_in">size</span>() &gt; maxWidth)<br>            &#123;<br>                <span class="hljs-type">int</span> space = cnt &gt; <span class="hljs-number">1</span> ? ((maxWidth - width) / (cnt - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> remain = cnt &gt; <span class="hljs-number">1</span> ? ((maxWidth - width) % (cnt - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (processingIndex &lt; i)<br>                &#123;<br>                    std::string front = words[processingIndex++];<br>                    result += front;<br><br>                    <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)<br>                    &#123;<br>                        result += std::<span class="hljs-built_in">string</span>(maxWidth - width, <span class="hljs-string">&#x27; &#x27;</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (processingIndex &lt; i)<br>                    &#123;<br>                        result += std::<span class="hljs-built_in">string</span>(space + (remain-- &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), <span class="hljs-string">&#x27; &#x27;</span>);<br>                    &#125;<br>                &#125;<br>                results.<span class="hljs-built_in">push_back</span>(result);<br>                cnt = <span class="hljs-number">0</span>;<br>                width = <span class="hljs-number">0</span>;<br>                result.<span class="hljs-built_in">clear</span>();<br>            &#125;<br>            width += words[i].<span class="hljs-built_in">size</span>();<br>            ++cnt;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (processingIndex &lt; n)<br>        &#123;<br>            std::string front = words[processingIndex++];<br>            result += front;<br>            <span class="hljs-keyword">if</span> (processingIndex &lt; n)<br>            &#123;<br>                result += <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result += std::<span class="hljs-built_in">string</span>(maxWidth - width - (cnt - <span class="hljs-number">1</span>), <span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>        &#125;<br>        results.<span class="hljs-built_in">push_back</span>(result);<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-28</title>
    <link href="/posts/ee3825b1/"/>
    <url>/posts/ee3825b1/</url>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description">有这么一道题</a>，判断一个字符串（模式串）是否为另一个字符串（主串）的子串，返回出现的索引。</p><p>朴素暴力的方法居然是0ms，但这并不代表写得好。</p><h1 id="Knuth–Morris–Pratt"><a href="#Knuth–Morris–Pratt" class="headerlink" title="Knuth–Morris–Pratt"></a>Knuth–Morris–Pratt</h1><p>对于字符串匹配算法，截至此题，我还不会KMP算法，借此学习一下</p><p>参考：</p><ul><li><a href="https://oi-wiki.org/string/kmp/">前缀函数与 KMP 算法</a></li><li><a href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法</a></li></ul><p>最最朴素的匹配算法，将模式串与主串头部对齐，逐位比较，若中途比对失败，则将整个模式串后移一位，重新从头开始逐位。那么其实比对失败之前遍历过的字符也是蕴含了信息的，需要一个空间换时间的方法来使用这些信息。</p><p>在参考资料中，这些被naive算法忽略的信息可以用“前缀函数”（或者next数组）来表示，其定义为：<br>$$<br>\pi[i] &#x3D; max_{k&#x3D;0…i}{k:s[0…k-1]&#x3D;&#x3D;s[i-(k-1)…i]}<br>$$</p><p>也就是 $\pi[i]$ 表示的是模式串的子串 $s[0…i]$ 最长相等的真前缀与真后缀的长度。它的意义是，如果字符串 $s$ 匹配到了某处索引 $i$ 发现不匹配了，但是之前的子串中有 $\pi[i-1] &gt; 0$ 也就是该后缀与前缀的某个位置匹配， 那就可以跳过后缀前缀之间的区域，直接将搜索词往后移动 $i - \pi[i-1]$ 位，并继续从当前索引开始比较。</p><p>所以KMP算法的步骤是</p><ul><li>建表</li><li>搜索</li></ul><p>接下来是建表算法，主要是解决了匹配失败后只能一格一格移动模式串的问题，可以直接得出模式串可以一步到位移动多远：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPrefix</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pi</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, j) == s.<span class="hljs-built_in">substr</span>(i - j + <span class="hljs-number">1</span>, j))<br>            &#123;<br>                pi[i] = j;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pi;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是朴素的建表算法，复杂度$O(n^3)$，每次子串增长，内层循环 $j$ 都是从一位开始寻找相等的前后缀，这里可以优化。子串从 $s[0…i]$ 增长到 $s[0…i+1]$ 后，要么 $s[i+1] &#x3D;&#x3D; s[\pi[i] + 1]$，要么不等，所以:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPrefix</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pi</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = pi[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, j) == s.<span class="hljs-built_in">substr</span>(i - j + <span class="hljs-number">1</span>, j))<br>            &#123;<br>                pi[i] = j;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pi;<br>&#125;<br></code></pre></td></tr></table></figure><p>网上找到了一个 $O(n)$ 的版本，本人水平有限暂时无法解释如何从上面想到这段代码，先贴在这里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(s.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j])<br>            j = next[j - <span class="hljs-number">1</span>];<br>        j += (s[i] == s[j]);<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPrefix</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pi</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = pi[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, j) == s.<span class="hljs-built_in">substr</span>(i - j + <span class="hljs-number">1</span>, j))<br>                &#123;<br>                    pi[i] = j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pi;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><br>        std::vector&lt;<span class="hljs-type">int</span>&gt; prefix = <span class="hljs-built_in">getPrefix</span>(needle);<br><br>        <span class="hljs-keyword">while</span>(i &lt; haystack.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; needle.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(haystack[i] != needle[j])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    j -= j - prefix[j<span class="hljs-number">-1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    ++i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ++i;<br>                ++j;<br><br>                <span class="hljs-keyword">if</span>(j &gt;= needle.<span class="hljs-built_in">size</span>())<br>                &#123;<br>                    <span class="hljs-keyword">return</span> i - needle.<span class="hljs-built_in">size</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最终版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j])<br>                j = next[j - <span class="hljs-number">1</span>];<br><br>            j += (s[i] == s[j]);<br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        std::vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">getNext</span>(needle);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j])<br>                j = next[j - <span class="hljs-number">1</span>];<br><br>            j += (haystack[i] == needle[j]);<br>            <span class="hljs-keyword">if</span>(j &gt;= needle.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-6</title>
    <link href="/posts/3e432905/"/>
    <url>/posts/3e432905/</url>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/zigzag-conversion/description">有这么一道题</a>，Zigzag重排字符串，将源字符串按照倒置的N字排列，然后按照行逐行合并为新字符串。</p><p>感觉思路比较显然，多个倒置N形状可以看作多个”V”部分的周期图形，那么只需要遍历源字符串，通过取余映射到每一行就行了。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>这里采用一个<code>std::string</code>数组来存储每一行的字符串；然后只需要区分是在”V”形状的左翼还是右翼就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">results</span><span class="hljs-params">(numRows, <span class="hljs-string">&quot;&quot;</span>)</span></span>; <br><br>        <span class="hljs-type">int</span> groupNum = (numRows - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> m = groupNum &gt; <span class="hljs-number">0</span> ? (i % groupNum) : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> newIndex = (m &gt; numRows<span class="hljs-number">-1</span>)?(groupNum-m):m;<br>            results[newIndex] += s[i];<br>        &#125;<br><br>        std::string result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; ++i)<br>        &#123;<br>            result += results[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-42</title>
    <link href="/posts/58b76b29/"/>
    <url>/posts/58b76b29/</url>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/trapping-rain-water/description">有这么一道题</a>，2D接雨水，给你一个序列，代表以x轴为底、y轴为高的2D空间中的一块凹凸不同的地，问你这块地形能接住多少格1x1的雨水？序列的两边没有空气墙。</p><p>第一眼，我的想法是遍历这个序列，寻找“凹”字形的子串，需要考虑到，这个“凹”字的两端可能前高后低、前低后高；也可能不止一个“凹”，而是类似“山”字，中间有很多小峰值，两边比中间还要高。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="纯模拟-——-个人命名为左向填水、随时回填式"><a href="#纯模拟-——-个人命名为左向填水、随时回填式" class="headerlink" title="纯模拟 —— 个人命名为左向填水、随时回填式"></a>纯模拟 —— 个人命名为左向填水、随时回填式</h2><p>并没有想到任何算法范式，直接模拟开干。我们都知道接水需要遵循木桶效应，那么只需要在检测到“凹”字形的时候，计算“凹”中的短板能接住多少雨水。需要注意，由于我们是从前向后遍历序列，不知道后面的地形对前面地形的影响，也就是说可能后面一堵大墙能接住很多雨水，也有可能一路下坡水漏光了。因此每次检测到“凹”时就立刻接雨水，并将接过雨水的地方“填平”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">myMap</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> highest = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            myMap[i] = height[i];<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; highest &gt; <span class="hljs-number">0</span> &amp;&amp; height[i] &gt; myMap[i - <span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-type">int</span> level = std::<span class="hljs-built_in">min</span>(height[i], highest);<br>                <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; myMap[j] &lt; level)<br>                &#123;<br>                    ret += (level - myMap[j]);<br>                    myMap[j] = level;<br>                    --j;<br>                &#125;<br>            &#125;<br>            highest = std::<span class="hljs-built_in">max</span>(highest, myMap[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-135</title>
    <link href="/posts/d98bf703/"/>
    <url>/posts/d98bf703/</url>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/candy/description">有这么一道题</a>，分糖果，每个孩子至少一颗，分比旁边孩子更高的孩子要分到更多的糖果，问给所有的孩子最少分几颗。</p><p>看到这道题第一眼，求一个“最少”的数量，很有动态规划的味道。继续分析：</p><ul><li>对于<strong>重叠子问题</strong>，每个孩子的状态是独立的，仅依赖于左右邻居的值，不存在大量子问题被重复计算；</li><li>对于<strong>无后效性</strong>，也就似是当前决策不会影响到后面的状态转移，本题部分满足，但是不太对劲，因为当前$i$孩子分到的糖果并不能仅依靠$i-1$来决定，还会受到$i+1$的影响，也就是说当前决策依赖未来信息，存在<strong>后效性</strong>；</li><li>对于<strong>最优子结构</strong>，如果能确保每个孩子的最优糖果数是基于他和邻居之间子结构的最优安排，而整条队伍的最优解就是所有局部子问题的最优解之和，本题是具有最优子结构的。</li></ul><p>由于不满足<strong>重叠子问题</strong>和<strong>无后效性</strong>，我放弃了动态规划的解法。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h2><p>我随手列了几种情况，发现在数组<code>ratings</code>（孩子的分数）子串递增&#x2F;递减的时候才需要考虑相邻孩子的分数关系，相等的时候可以直接降为1。所以直觉告诉我“递增&#x2F;递减”可以做文章，既然<code>ratings</code>递增时糖果需要递增，而递减时糖果也需要递减，那为何不从后往前遍历，把“递减”转化为“递增”？</p><p>结果是碰巧撞对了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candies</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">-1</span>])<br>            &#123;<br>                candies[i] = candies[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">+1</span>])<br>            &#123;<br>                <span class="hljs-keyword">while</span>(candies[i] &lt;= candies[i<span class="hljs-number">+1</span>])<br>                    ++candies[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            ret += candies[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>改良：</p><p>完全不用while</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">+1</span>])<br>&#123;<br>    <span class="hljs-keyword">while</span>(candies[i] &lt;= candies[i<span class="hljs-number">+1</span>])<br>                    ++candies[i];<br>&#125;<br><br><span class="hljs-comment">// =&gt;</span><br><br><span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">+1</span>] &amp;&amp; candies[i] &lt;= candies[i<span class="hljs-number">+1</span>])<br>&#123;<br>    candies[i] = candies[i<span class="hljs-number">+1</span>] + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后还发现，正向遍历检测递增和反向遍历检测递减其实互不影响，只有在$i-m$~$i$递增，且$i$~$i+n$递减这种时候会有一个重叠的索引$i$，那么可以在一个循环中同时推进双边的遍历，然后在判断条件中防止被后写入的糖果值覆盖：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candies</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> j = n - i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">-1</span>] &amp;&amp; candies[i] &lt;= candies[i<span class="hljs-number">-1</span>])<br>            &#123;<br>                candies[i] = candies[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ratings[j] &gt; ratings[j<span class="hljs-number">+1</span>] &amp;&amp; candies[j] &lt;= candies[j<span class="hljs-number">+1</span>])<br>            &#123;<br>                candies[j] = candies[j<span class="hljs-number">+1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(candies.<span class="hljs-built_in">begin</span>(), candies.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
