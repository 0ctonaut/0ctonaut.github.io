<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hotcat&#39;s blog</title>
  
  
  <link href="https://hotcat.work/feed.xml" rel="self"/>
  
  <link href="https://hotcat.work/"/>
  <updated>2025-07-24T02:57:23.363Z</updated>
  <id>https://hotcat.work/</id>
  
  <author>
    <name>Hotcat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-68</title>
    <link href="https://hotcat.work/posts/8a54e0b5/"/>
    <id>https://hotcat.work/posts/8a54e0b5/</id>
    <published>2025-07-24T02:37:39.806Z</published>
    <updated>2025-07-24T02:57:23.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/text-justification/description">有这么一道题</a>，给你一句字符串，按照规则塞入一个限宽的<code>string</code>数组中。</p><p>其中规则如下：</p><ol><li>“单词”定义为连续无空格的字符串，单词之间至少拥有一个空格；</li><li>数组的每个<code>string</code>等宽，宽度都是<code>maxWidth</code>，若宽度不足，需要补齐空格；</li><li>空格均匀分布，若不能均匀分布，在尽量均匀的情况下保证左边的空格数量更多；</li><li>对于只有一个单词的行，该行左对齐，即空格全部分布在单词右边；</li><li>数组的最后一行即使有多个单词，也需要在保证<code>1.</code>的前提下实现<code>4.</code></li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>没啥好说的，贪心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fullJustify</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> maxWidth)</span> </span>&#123;<br>        std::queue&lt;std::string&gt; line;<br>        <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        std::vector&lt;std::string&gt; results;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (width + cnt + words[i].<span class="hljs-built_in">size</span>() &gt; maxWidth)<br>            &#123;<br>                <span class="hljs-type">int</span> space = cnt &gt; <span class="hljs-number">1</span> ? ((maxWidth - width) / (cnt - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> remain = cnt &gt; <span class="hljs-number">1</span> ? ((maxWidth - width) % (cnt - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>                std::string result;<br>                <span class="hljs-keyword">while</span> (!line.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    std::string front = line.<span class="hljs-built_in">front</span>();<br>                    line.<span class="hljs-built_in">pop</span>();<br>                    result += front;<br>                    <span class="hljs-keyword">if</span> (!line.<span class="hljs-built_in">empty</span>())<br>                    &#123;<br>                        result += std::<span class="hljs-built_in">string</span>(space + (remain-- &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), <span class="hljs-string">&#x27; &#x27;</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)<br>                    &#123;<br>                        result += std::<span class="hljs-built_in">string</span>(maxWidth - width, <span class="hljs-string">&#x27; &#x27;</span>);<br>                    &#125;<br>                &#125;<br>                results.<span class="hljs-built_in">push_back</span>(result);<br>                cnt = <span class="hljs-number">0</span>;<br>                width = <span class="hljs-number">0</span>;<br>            &#125;<br>            line.<span class="hljs-built_in">push</span>(words[i]);<br>            width += words[i].<span class="hljs-built_in">size</span>();<br>            ++cnt;<br>        &#125;<br><br>        std::string result;<br>        <span class="hljs-keyword">while</span> (!line.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            std::string front = line.<span class="hljs-built_in">front</span>();<br>            line.<span class="hljs-built_in">pop</span>();<br>            result += front;<br>            <span class="hljs-keyword">if</span> (!line.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                result += <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result += std::<span class="hljs-built_in">string</span>(maxWidth - width - (cnt - <span class="hljs-number">1</span>), <span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>        &#125;<br>        results.<span class="hljs-built_in">push_back</span>(result);<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以用索引代替<code>std::queue</code>来优化一点空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fullJustify</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> maxWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> processingIndex = <span class="hljs-number">0</span>;<br>        std::string result;<br>        std::vector&lt;std::string&gt; results;<br>        <span class="hljs-type">int</span> n = words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (width + cnt + words[i].<span class="hljs-built_in">size</span>() &gt; maxWidth)<br>            &#123;<br>                <span class="hljs-type">int</span> space = cnt &gt; <span class="hljs-number">1</span> ? ((maxWidth - width) / (cnt - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> remain = cnt &gt; <span class="hljs-number">1</span> ? ((maxWidth - width) % (cnt - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (processingIndex &lt; i)<br>                &#123;<br>                    std::string front = words[processingIndex++];<br>                    result += front;<br><br>                    <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)<br>                    &#123;<br>                        result += std::<span class="hljs-built_in">string</span>(maxWidth - width, <span class="hljs-string">&#x27; &#x27;</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (processingIndex &lt; i)<br>                    &#123;<br>                        result += std::<span class="hljs-built_in">string</span>(space + (remain-- &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), <span class="hljs-string">&#x27; &#x27;</span>);<br>                    &#125;<br>                &#125;<br>                results.<span class="hljs-built_in">push_back</span>(result);<br>                cnt = <span class="hljs-number">0</span>;<br>                width = <span class="hljs-number">0</span>;<br>                result.<span class="hljs-built_in">clear</span>();<br>            &#125;<br>            width += words[i].<span class="hljs-built_in">size</span>();<br>            ++cnt;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (processingIndex &lt; n)<br>        &#123;<br>            std::string front = words[processingIndex++];<br>            result += front;<br>            <span class="hljs-keyword">if</span> (processingIndex &lt; n)<br>            &#123;<br>                result += <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result += std::<span class="hljs-built_in">string</span>(maxWidth - width - (cnt - <span class="hljs-number">1</span>), <span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>        &#125;<br>        results.<span class="hljs-built_in">push_back</span>(result);<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intuition&quot;&gt;&lt;a href=&quot;#Intuition&quot; class=&quot;headerlink&quot; title=&quot;Intuition&quot;&gt;&lt;/a&gt;Intuition&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/tex</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hotcat.work/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-28</title>
    <link href="https://hotcat.work/posts/ee3825b1/"/>
    <id>https://hotcat.work/posts/ee3825b1/</id>
    <published>2025-07-23T13:53:55.150Z</published>
    <updated>2025-07-24T00:31:19.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description">有这么一道题</a>，判断一个字符串（模式串）是否为另一个字符串（主串）的子串，返回出现的索引。</p><p>朴素暴力的方法居然是0ms，但这并不代表写得好。</p><h1 id="Knuth–Morris–Pratt"><a href="#Knuth–Morris–Pratt" class="headerlink" title="Knuth–Morris–Pratt"></a>Knuth–Morris–Pratt</h1><p>对于字符串匹配算法，截至此题，我还不会KMP算法，借此学习一下</p><p>参考：</p><ul><li><a href="https://oi-wiki.org/string/kmp/">前缀函数与 KMP 算法</a></li><li><a href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法</a></li></ul><p>最最朴素的匹配算法，将模式串与主串头部对齐，逐位比较，若中途比对失败，则将整个模式串后移一位，重新从头开始逐位。那么其实比对失败之前遍历过的字符也是蕴含了信息的，需要一个空间换时间的方法来使用这些信息。</p><p>在参考资料中，这些被naive算法忽略的信息可以用“前缀函数”（或者next数组）来表示，其定义为：<br>$$<br>\pi[i] &#x3D; max_{k&#x3D;0…i}{k:s[0…k-1]&#x3D;&#x3D;s[i-(k-1)…i]}<br>$$</p><p>也就是 $\pi[i]$ 表示的是模式串的子串 $s[0…i]$ 最长相等的真前缀与真后缀的长度。它的意义是，如果字符串 $s$ 匹配到了某处索引 $i$ 发现不匹配了，但是之前的子串中有 $\pi[i-1] &gt; 0$ 也就是该后缀与前缀的某个位置匹配， 那就可以跳过后缀前缀之间的区域，直接将搜索词往后移动 $i - \pi[i-1]$ 位，并继续从当前索引开始比较。</p><p>所以KMP算法的步骤是</p><ul><li>建表</li><li>搜索</li></ul><p>接下来是建表算法，主要是解决了匹配失败后只能一格一格移动模式串的问题，可以直接得出模式串可以一步到位移动多远：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPrefix</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pi</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, j) == s.<span class="hljs-built_in">substr</span>(i - j + <span class="hljs-number">1</span>, j))<br>            &#123;<br>                pi[i] = j;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pi;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是朴素的建表算法，复杂度$O(n^3)$，每次子串增长，内层循环 $j$ 都是从一位开始寻找相等的前后缀，这里可以优化。子串从 $s[0…i]$ 增长到 $s[0…i+1]$ 后，要么 $s[i+1] &#x3D;&#x3D; s[\pi[i] + 1]$，要么不等，所以:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPrefix</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pi</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = pi[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, j) == s.<span class="hljs-built_in">substr</span>(i - j + <span class="hljs-number">1</span>, j))<br>            &#123;<br>                pi[i] = j;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pi;<br>&#125;<br></code></pre></td></tr></table></figure><p>网上找到了一个 $O(n)$ 的版本，本人水平有限暂时无法解释如何从上面想到这段代码，先贴在这里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(s.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j])<br>            j = next[j - <span class="hljs-number">1</span>];<br>        j += (s[i] == s[j]);<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPrefix</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pi</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = pi[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, j) == s.<span class="hljs-built_in">substr</span>(i - j + <span class="hljs-number">1</span>, j))<br>                &#123;<br>                    pi[i] = j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pi;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><br>        std::vector&lt;<span class="hljs-type">int</span>&gt; prefix = <span class="hljs-built_in">getPrefix</span>(needle);<br><br>        <span class="hljs-keyword">while</span>(i &lt; haystack.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; needle.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(haystack[i] != needle[j])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    j -= j - prefix[j<span class="hljs-number">-1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    ++i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ++i;<br>                ++j;<br><br>                <span class="hljs-keyword">if</span>(j &gt;= needle.<span class="hljs-built_in">size</span>())<br>                &#123;<br>                    <span class="hljs-keyword">return</span> i - needle.<span class="hljs-built_in">size</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最终版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j])<br>                j = next[j - <span class="hljs-number">1</span>];<br><br>            j += (s[i] == s[j]);<br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        std::vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">getNext</span>(needle);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j])<br>                j = next[j - <span class="hljs-number">1</span>];<br><br>            j += (haystack[i] == needle[j]);<br>            <span class="hljs-keyword">if</span>(j &gt;= needle.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intuition&quot;&gt;&lt;a href=&quot;#Intuition&quot; class=&quot;headerlink&quot; title=&quot;Intuition&quot;&gt;&lt;/a&gt;Intuition&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/fin</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hotcat.work/tags/leetcode/"/>
    
    <category term="KMP" scheme="https://hotcat.work/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-6</title>
    <link href="https://hotcat.work/posts/3e432905/"/>
    <id>https://hotcat.work/posts/3e432905/</id>
    <published>2025-07-21T13:37:30.295Z</published>
    <updated>2025-07-23T16:02:42.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/zigzag-conversion/description">有这么一道题</a>，Zigzag重排字符串，将源字符串按照倒置的N字排列，然后按照行逐行合并为新字符串。</p><p>感觉思路比较显然，多个倒置N形状可以看作多个”V”部分的周期图形，那么只需要遍历源字符串，通过取余映射到每一行就行了。</p><hr><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>这里采用一个<code>std::string</code>数组来存储每一行的字符串；然后只需要区分是在”V”形状的左翼还是右翼就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">results</span><span class="hljs-params">(numRows, <span class="hljs-string">&quot;&quot;</span>)</span></span>; <br><br>        <span class="hljs-type">int</span> groupNum = (numRows - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> m = groupNum &gt; <span class="hljs-number">0</span> ? (i % groupNum) : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> newIndex = (m &gt; numRows<span class="hljs-number">-1</span>)?(groupNum-m):m;<br>            results[newIndex] += s[i];<br>        &#125;<br><br>        std::string result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; ++i)<br>        &#123;<br>            result += results[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intuition&quot;&gt;&lt;a href=&quot;#Intuition&quot; class=&quot;headerlink&quot; title=&quot;Intuition&quot;&gt;&lt;/a&gt;Intuition&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/zig</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hotcat.work/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-42</title>
    <link href="https://hotcat.work/posts/58b76b29/"/>
    <id>https://hotcat.work/posts/58b76b29/</id>
    <published>2025-07-17T14:07:23.274Z</published>
    <updated>2025-07-17T23:15:01.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/trapping-rain-water/description">有这么一道题</a>，2D接雨水，给你一个序列，代表以x轴为底、y轴为高的2D空间中的一块凹凸不同的地，问你这块地形能接住多少格1x1的雨水？序列的两边没有空气墙。</p><p>第一眼，我的想法是遍历这个序列，寻找“凹”字形的子串，需要考虑到，这个“凹”字的两端可能前高后低、前低后高；也可能不止一个“凹”，而是类似“山”字，中间有很多小峰值，两边比中间还要高。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="纯模拟-——-个人命名为左向填水、随时回填式"><a href="#纯模拟-——-个人命名为左向填水、随时回填式" class="headerlink" title="纯模拟 —— 个人命名为左向填水、随时回填式"></a>纯模拟 —— 个人命名为左向填水、随时回填式</h2><p>并没有想到任何算法范式，直接模拟开干。我们都知道接水需要遵循木桶效应，那么只需要在检测到“凹”字形的时候，计算“凹”中的短板能接住多少雨水。需要注意，由于我们是从前向后遍历序列，不知道后面的地形对前面地形的影响，也就是说可能后面一堵大墙能接住很多雨水，也有可能一路下坡水漏光了。因此每次检测到“凹”时就立刻接雨水，并将接过雨水的地方“填平”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">myMap</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> highest = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            myMap[i] = height[i];<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; highest &gt; <span class="hljs-number">0</span> &amp;&amp; height[i] &gt; myMap[i - <span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-type">int</span> level = std::<span class="hljs-built_in">min</span>(height[i], highest);<br>                <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; myMap[j] &lt; level)<br>                &#123;<br>                    ret += (level - myMap[j]);<br>                    myMap[j] = level;<br>                    --j;<br>                &#125;<br>            &#125;<br>            highest = std::<span class="hljs-built_in">max</span>(highest, myMap[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intuition&quot;&gt;&lt;a href=&quot;#Intuition&quot; class=&quot;headerlink&quot; title=&quot;Intuition&quot;&gt;&lt;/a&gt;Intuition&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/tra</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hotcat.work/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-135</title>
    <link href="https://hotcat.work/posts/d98bf703/"/>
    <id>https://hotcat.work/posts/d98bf703/</id>
    <published>2025-07-16T14:59:42.954Z</published>
    <updated>2025-07-17T23:15:01.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><p><a href="https://leetcode.com/problems/candy/description">有这么一道题</a>，分糖果，每个孩子至少一颗，分比旁边孩子更高的孩子要分到更多的糖果，问给所有的孩子最少分几颗。</p><p>看到这道题第一眼，求一个“最少”的数量，很有动态规划的味道。继续分析：</p><ul><li>对于<strong>重叠子问题</strong>，每个孩子的状态是独立的，仅依赖于左右邻居的值，不存在大量子问题被重复计算；</li><li>对于<strong>无后效性</strong>，也就似是当前决策不会影响到后面的状态转移，本题部分满足，但是不太对劲，因为当前$i$孩子分到的糖果并不能仅依靠$i-1$来决定，还会受到$i+1$的影响，也就是说当前决策依赖未来信息，存在<strong>后效性</strong>；</li><li>对于<strong>最优子结构</strong>，如果能确保每个孩子的最优糖果数是基于他和邻居之间子结构的最优安排，而整条队伍的最优解就是所有局部子问题的最优解之和，本题是具有最优子结构的。</li></ul><p>由于不满足<strong>重叠子问题</strong>和<strong>无后效性</strong>，我放弃了动态规划的解法。</p><hr><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h2><p>我随手列了几种情况，发现在数组<code>ratings</code>（孩子的分数）子串递增&#x2F;递减的时候才需要考虑相邻孩子的分数关系，相等的时候可以直接降为1。所以直觉告诉我“递增&#x2F;递减”可以做文章，既然<code>ratings</code>递增时糖果需要递增，而递减时糖果也需要递减，那为何不从后往前遍历，把“递减”转化为“递增”？</p><p>结果是碰巧撞对了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candies</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">-1</span>])<br>            &#123;<br>                candies[i] = candies[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">+1</span>])<br>            &#123;<br>                <span class="hljs-keyword">while</span>(candies[i] &lt;= candies[i<span class="hljs-number">+1</span>])<br>                    ++candies[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            ret += candies[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>改良：</p><p>完全不用while</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">+1</span>])<br>&#123;<br>    <span class="hljs-keyword">while</span>(candies[i] &lt;= candies[i<span class="hljs-number">+1</span>])<br>                    ++candies[i];<br>&#125;<br><br><span class="hljs-comment">// =&gt;</span><br><br><span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">+1</span>] &amp;&amp; candies[i] &lt;= candies[i<span class="hljs-number">+1</span>])<br>&#123;<br>    candies[i] = candies[i<span class="hljs-number">+1</span>] + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后还发现，正向遍历检测递增和反向遍历检测递减其实互不影响，只有在$i-m$~$i$递增，且$i$~$i+n$递减这种时候会有一个重叠的索引$i$，那么可以在一个循环中同时推进双边的遍历，然后在判断条件中防止被后写入的糖果值覆盖：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candies</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> j = n - i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">-1</span>] &amp;&amp; candies[i] &lt;= candies[i<span class="hljs-number">-1</span>])<br>            &#123;<br>                candies[i] = candies[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ratings[j] &gt; ratings[j<span class="hljs-number">+1</span>] &amp;&amp; candies[j] &lt;= candies[j<span class="hljs-number">+1</span>])<br>            &#123;<br>                candies[j] = candies[j<span class="hljs-number">+1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(candies.<span class="hljs-built_in">begin</span>(), candies.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intuition&quot;&gt;&lt;a href=&quot;#Intuition&quot; class=&quot;headerlink&quot; title=&quot;Intuition&quot;&gt;&lt;/a&gt;Intuition&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/can</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://hotcat.work/tags/leetcode/"/>
    
  </entry>
  
</feed>
